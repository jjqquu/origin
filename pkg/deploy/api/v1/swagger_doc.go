package v1

// This file contains methods that can be used by the go-restful package to generate Swagger
// documentation for the object types found in 'types.go' This file is automatically generated
// by hack/update-generated-swagger-descriptions.sh and should be run after a full build of OpenShift.
// ==== DO NOT EDIT THIS FILE MANUALLY ====

var map_CustomDeploymentStrategyParams = map[string]string{
	"":            "CustomDeploymentStrategyParams are the input to the Custom deployment strategy.",
	"image":       "Image specifies a Docker image which can carry out a deployment.",
	"environment": "Environment holds the environment which will be given to the container for Image.",
	"command":     "Command is optional and overrides CMD in the container Image.",
}

func (CustomDeploymentStrategyParams) SwaggerDoc() map[string]string {
	return map_CustomDeploymentStrategyParams
}

var map_DeploymentCause = map[string]string{
	"":             "DeploymentCause captures information about a particular cause of a deployment.",
	"type":         "Type of the trigger that resulted in the creation of a new deployment",
	"imageTrigger": "ImageTrigger contains the image trigger details, if this trigger was fired based on an image change",
}

func (DeploymentCause) SwaggerDoc() map[string]string {
	return map_DeploymentCause
}

var map_DeploymentCauseImageTrigger = map[string]string{
	"":     "DeploymentCauseImageTrigger represents details about the cause of a deployment originating from an image change trigger",
	"from": "From is a reference to the changed object which triggered a deployment. The field may have the kinds DockerImage, ImageStreamTag, or ImageStreamImage.",
}

func (DeploymentCauseImageTrigger) SwaggerDoc() map[string]string {
	return map_DeploymentCauseImageTrigger
}

var map_DeploymentConfig = map[string]string{
	"":         "DeploymentConfig represents a configuration for a single deployment (represented as a ReplicationController). It also contains details about changes which resulted in the current state of the DeploymentConfig. Each change to the DeploymentConfig which should result in a new deployment results in an increment of LatestVersion.",
	"metadata": "Standard object's metadata.",
	"spec":     "Spec represents a desired deployment state and how to deploy to it.",
	"status":   "Status represents the current deployment state.",
}

func (DeploymentConfig) SwaggerDoc() map[string]string {
	return map_DeploymentConfig
}

var map_DeploymentConfigList = map[string]string{
	"":         "DeploymentConfigList is a collection of deployment configs.",
	"metadata": "Standard object's metadata.",
	"items":    "Items is a list of deployment configs",
}

func (DeploymentConfigList) SwaggerDoc() map[string]string {
	return map_DeploymentConfigList
}

var map_DeploymentConfigRollback = map[string]string{
	"":                   "DeploymentConfigRollback provides the input to rollback generation.",
	"name":               "Name of the deployment config that will be rolled back.",
	"updatedAnnotations": "UpdatedAnnotations is a set of new annotations that will be added in the deployment config.",
	"spec":               "Spec defines the options to rollback generation.",
}

func (DeploymentConfigRollback) SwaggerDoc() map[string]string {
	return map_DeploymentConfigRollback
}

var map_DeploymentConfigRollbackSpec = map[string]string{
	"":                       "DeploymentConfigRollbackSpec represents the options for rollback generation.",
	"from":                   "From points to a ReplicationController which is a deployment.",
	"revision":               "Revision to rollback to. If set to 0, rollback to the last revision.",
	"includeTriggers":        "IncludeTriggers specifies whether to include config Triggers.",
	"includeTemplate":        "IncludeTemplate specifies whether to include the PodTemplateSpec.",
	"includeReplicationMeta": "IncludeReplicationMeta specifies whether to include the replica count and selector.",
	"includeStrategy":        "IncludeStrategy specifies whether to include the deployment Strategy.",
}

func (DeploymentConfigRollbackSpec) SwaggerDoc() map[string]string {
	return map_DeploymentConfigRollbackSpec
}

var map_DeploymentConfigSpec = map[string]string{
	"":                     "DeploymentConfigSpec represents the desired state of the deployment.",
	"strategy":             "Strategy describes how a deployment is executed.",
	"minReadySeconds":      "MinReadySeconds is the minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)",
	"triggers":             "Triggers determine how updates to a DeploymentConfig result in new deployments. If no triggers are defined, a new deployment can only occur as a result of an explicit client update to the DeploymentConfig with a new LatestVersion. If null, defaults to having a config change trigger.",
	"replicas":             "Replicas is the number of desired replicas.",
	"revisionHistoryLimit": "RevisionHistoryLimit is the number of old ReplicationControllers to retain to allow for rollbacks. This field is a pointer to allow for differentiation between an explicit zero and not specified.",
	"test":                 "Test ensures that this deployment config will have zero replicas except while a deployment is running. This allows the deployment config to be used as a continuous deployment test - triggering on images, running the deployment, and then succeeding or failing. Post strategy hooks and After actions can be used to integrate successful deployment with an action.",
	"paused":               "Paused indicates that the deployment config is paused resulting in no new deployments on template changes or changes in the template caused by other triggers.",
	"selector":             "Selector is a label query over pods that should match the Replicas count.",
	"template":             "Template is the object that describes the pod that will be created if insufficient replicas are detected.",
	"site":                 "Site is the identifier that specifies the site where deployment will be conducted",
	"marathonAppTemplate":  "MarathonAppTemplate is the object that describes the application that will be created by mesos Marathon scheduler",
}

func (DeploymentConfigSpec) SwaggerDoc() map[string]string {
	return map_DeploymentConfigSpec
}

var map_DeploymentConfigStatus = map[string]string{
	"":                    "DeploymentConfigStatus represents the current deployment state.",
	"latestVersion":       "LatestVersion is used to determine whether the current deployment associated with a deployment config is out of sync.",
	"observedGeneration":  "ObservedGeneration is the most recent generation observed by the deployment config controller.",
	"replicas":            "Replicas is the total number of pods targeted by this deployment config.",
	"updatedReplicas":     "UpdatedReplicas is the total number of non-terminated pods targeted by this deployment config that have the desired template spec.",
	"availableReplicas":   "AvailableReplicas is the total number of available pods targeted by this deployment config.",
	"unavailableReplicas": "UnavailableReplicas is the total number of unavailable pods targeted by this deployment config.",
	"details":             "Details are the reasons for the update to this deployment config. This could be based on a change made by the user or caused by an automatic trigger",
}

func (DeploymentConfigStatus) SwaggerDoc() map[string]string {
	return map_DeploymentConfigStatus
}

var map_DeploymentDetails = map[string]string{
	"":        "DeploymentDetails captures information about the causes of a deployment.",
	"message": "Message is the user specified change message, if this deployment was triggered manually by the user",
	"causes":  "Causes are extended data associated with all the causes for creating a new deployment",
}

func (DeploymentDetails) SwaggerDoc() map[string]string {
	return map_DeploymentDetails
}

var map_DeploymentLog = map[string]string{
	"": "DeploymentLog represents the logs for a deployment",
}

func (DeploymentLog) SwaggerDoc() map[string]string {
	return map_DeploymentLog
}

var map_DeploymentLogOptions = map[string]string{
	"":             "DeploymentLogOptions is the REST options for a deployment log",
	"container":    "The container for which to stream logs. Defaults to only container if there is one container in the pod.",
	"follow":       "Follow if true indicates that the build log should be streamed until the build terminates.",
	"previous":     "Return previous deployment logs. Defaults to false.",
	"sinceSeconds": "A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.",
	"sinceTime":    "An RFC3339 timestamp from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.",
	"timestamps":   "If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.",
	"tailLines":    "If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime",
	"limitBytes":   "If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.",
	"nowait":       "NoWait if true causes the call to return immediately even if the deployment is not available yet. Otherwise the server will wait until the deployment has started.",
	"version":      "Version of the deployment for which to view logs.",
}

func (DeploymentLogOptions) SwaggerDoc() map[string]string {
	return map_DeploymentLogOptions
}

var map_DeploymentStrategy = map[string]string{
	"":               "DeploymentStrategy describes how to perform a deployment.",
	"type":           "Type is the name of a deployment strategy.",
	"customParams":   "CustomParams are the input to the Custom deployment strategy.",
	"recreateParams": "RecreateParams are the input to the Recreate deployment strategy.",
	"rollingParams":  "RollingParams are the input to the Rolling deployment strategy.",
	"resources":      "Resources contains resource requirements to execute the deployment and any hooks",
	"labels":         "Labels is a set of key, value pairs added to custom deployer and lifecycle pre/post hook pods.",
	"annotations":    "Annotations is a set of key, value pairs added to custom deployer and lifecycle pre/post hook pods.",
}

func (DeploymentStrategy) SwaggerDoc() map[string]string {
	return map_DeploymentStrategy
}

var map_DeploymentTriggerImageChangeParams = map[string]string{
	"":                   "DeploymentTriggerImageChangeParams represents the parameters to the ImageChange trigger.",
	"automatic":          "Automatic means that the detection of a new tag value should result in an image update inside the pod template. Deployment configs that haven't been deployed yet will always have their images updated. Deployment configs that have been deployed at least once, will have their images updated only if this is set to true.",
	"containerNames":     "ContainerNames is used to restrict tag updates to the specified set of container names in a pod.",
	"from":               "From is a reference to an image stream tag to watch for changes. From.Name is the only required subfield - if From.Namespace is blank, the namespace of the current deployment trigger will be used.",
	"lastTriggeredImage": "LastTriggeredImage is the last image to be triggered.",
}

func (DeploymentTriggerImageChangeParams) SwaggerDoc() map[string]string {
	return map_DeploymentTriggerImageChangeParams
}

var map_DeploymentTriggerPolicy = map[string]string{
	"":                  "DeploymentTriggerPolicy describes a policy for a single trigger that results in a new deployment.",
	"type":              "Type of the trigger",
	"imageChangeParams": "ImageChangeParams represents the parameters for the ImageChange trigger.",
}

func (DeploymentTriggerPolicy) SwaggerDoc() map[string]string {
	return map_DeploymentTriggerPolicy
}

var map_ExecNewPodHook = map[string]string{
	"":              "ExecNewPodHook is a hook implementation which runs a command in a new pod based on the specified container which is assumed to be part of the deployment template.",
	"command":       "Command is the action command and its arguments.",
	"env":           "Env is a set of environment variables to supply to the hook pod's container.",
	"containerName": "ContainerName is the name of a container in the deployment pod template whose Docker image will be used for the hook pod's container.",
	"volumes":       "Volumes is a list of named volumes from the pod template which should be copied to the hook pod. Volumes names not found in pod spec are ignored. An empty list means no volumes will be copied.",
}

func (ExecNewPodHook) SwaggerDoc() map[string]string {
	return map_ExecNewPodHook
}

var map_LifecycleHook = map[string]string{
	"":              "LifecycleHook defines a specific deployment lifecycle action. Only one type of action may be specified at any time.",
	"failurePolicy": "FailurePolicy specifies what action to take if the hook fails.",
	"execNewPod":    "ExecNewPod specifies the options for a lifecycle hook backed by a pod.",
	"tagImages":     "TagImages instructs the deployer to tag the current image referenced under a container onto an image stream tag.",
}

func (LifecycleHook) SwaggerDoc() map[string]string {
	return map_LifecycleHook
}

var map_MarathonApplication = map[string]string{
	"":                      "Application is the definition for an application in marathon",
	"id":                    "Unique identifier for the app consisting of a series of names separated by slashes.",
	"cmd":                   "The command that is executed.",
	"args":                  "An array of strings that represents an alternative mode of specifying the command to run.",
	"constraints":           "Valid constraint operators are one of [\"UNIQUE\", \"CLUSTER\", \"GROUP_BY\"].",
	"container":             "Container is the definition for a container type in marathon Additional data passed to the containerizer on application launch. These consist of a type, zero or more volumes, and additional type-specific options. Volumes and type are optional (the default type is DOCKER).",
	"cpus":                  "The number of CPU`s this application needs per instance.",
	"disk":                  "The number of DISK`s this application needs per instance.",
	"env":                   "Key value pairs that get added to the environment variables of the process to start.",
	"executor":              "The executor to use to launch this application.",
	"healthChecks":          "An array of checks to be performed on running tasks to determine if they are operating as expected. Health checks begin immediately upon task launch.",
	"mem":                   "The amount of memory in MB that is needed for the application per instance.",
	"ports":                 "Deprecated . Use portDefinitions instead.",
	"requirePorts":          "Normally, the host ports of your tasks are automatically assigned. This corresponds to the requirePorts value false which is the default. If you need more control and want to specify your host ports in advance, you can set requirePorts to true. This way the ports you have specified are used as host ports. That also means that Marathon can schedule the associated tasks only on hosts that have the specified ports available.",
	"backoffSeconds":        "Configures exponential backoff behavior when launching potentially sick apps. This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves. The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds. This applies also to tasks that are killed due to failing too many health checks. backoff seconds when failure happens",
	"backoffFactor":         "backoff factor used to multiplied by backoff seconds",
	"maxLaunchDelaySeconds": "Max launch delay seconds when launching potentially sick apps",
	"dependencies":          "A list of services upon which this application depends. An order is derived from the dependencies for performing start/stop and upgrade of the application. For example, an application /a relies on the services /b which itself relies on /c. To start all 3 applications, first /c is started than /b than /a.",
	"user":                  "User to launch the application container",
	"upgradeStrategy":       "During an upgrade all instances of an application get replaced by a new version.",
	"uris":                  "Since v0.15.0: Deprecated . Use fetch instead.",
	"labels":                "Attaching metadata to apps can be useful to expose additional information to other services, so we added the ability to place labels on apps (for example, you could label apps \"staging\" and \"production\" to mark services by their position in the pipeline).",
	"acceptedResourceRoles": "Optional. A list of resource roles. Marathon considers only resource offers with roles in this list for launching tasks of this app. If you do not specify this, Marathon considers all resource offers with roles that have been configured by the --default_accepted_resource_roles command line flag. If no --default_accepted_resource_roles was given on startup, Marathon considers all resource offers.",
	"fetch":                 "The list of URIs to fetch before the task starts.",
}

func (MarathonApplication) SwaggerDoc() map[string]string {
	return map_MarathonApplication
}

var map_MarathonConstraint = map[string]string{
	"":           "Constraint is the container placement constraint for scheduling an application in marathon",
	"constraint": "Valid constraint operators are one of [\"UNIQUE\", \"CLUSTER\", \"GROUP_BY\"].",
}

func (MarathonConstraint) SwaggerDoc() map[string]string {
	return map_MarathonConstraint
}

var map_MarathonContainer = map[string]string{
	"":        "Container is the definition for a container type in marathon",
	"type":    "\n container types, currelty \"docker\"/\"mesos\" supported",
	"docker":  "Docker is the docker definition from a marathon application",
	"volumes": "Volume is the docker volume details associated to the container",
}

func (MarathonContainer) SwaggerDoc() map[string]string {
	return map_MarathonContainer
}

var map_MarathonDocker = map[string]string{
	"":               "Docker is the docker definition from a marathon application",
	"forcePullImage": "ForcePullImage Flag force Docker to pull the image before launching each task, by default false.",
	"image":          "Image name of the docker container",
	"network":        "Network mode, currently support \"bridge\"/\"host\"/\"none\"",
	"parameters":     "The parameters object allows users to supply arbitrary command-line options for the docker run command executed by the Mesos containerizer.",
	"portMappings":   "PortMapping is the portmapping structure between container and mesos",
	"privileged":     "Privileged flag allows users to run containers in privileged mode. This flag is false by default.",
}

func (MarathonDocker) SwaggerDoc() map[string]string {
	return map_MarathonDocker
}

var map_MarathonFetch = map[string]string{
	"":           "Fetch will download URI before task starts",
	"uri":        "URI to be fetched by Mesos fetcher module",
	"executable": "Set fetched artifact as executable",
	"extract":    "Extract fetched artifact if supported by Mesos fetcher mod",
	"cache":      "Cache fetched artifact if supported by Mesos fetcher module",
}

func (MarathonFetch) SwaggerDoc() map[string]string {
	return map_MarathonFetch
}

var map_MarathonHealthCheck = map[string]string{
	"":          "Health checks to be performed by marathon on running tasks to determine if they are operating as expected.",
	"command":   "Command to run in order to determine the health of a task.",
	"portIndex": "(Optional. Default: 0): Index in this app's ports array to be used for health requests.",
	"path":      "(Optional. Default: \"/\"): Path to endpoint exposed by the task that will provide health status.",
	"maxConsecutiveFailures": "(Optional. Default: 3) : Number of consecutive health check failures after which the unhealthy task should be killed.",
	"protocol":               "\n (Optional. Default: \"HTTP\"): Protocol of the requests to be performed. One of \"HTTP\", \"HTTPS\", \"TCP\", or \"Command\".",
	"gracePeriodSeconds":     "(Optional. Default: 15): Health check failures are ignored within this number of seconds of the task being started or until the task becomes healthy for the first time.",
	"intervalSeconds":        "(Optional. Default: 10): Number of seconds to wait between health checks.",
	"timeoutSeconds":         "(Optional. Default: 20): Number of seconds after which a health check is considered a failure regardless of the response.",
}

func (MarathonHealthCheck) SwaggerDoc() map[string]string {
	return map_MarathonHealthCheck
}

var map_MarathonParameters = map[string]string{
	"":      "Parameters is the parameters to pass to the docker client when creating the container",
	"key":   "Paramenter key",
	"value": "Paramenter value",
}

func (MarathonParameters) SwaggerDoc() map[string]string {
	return map_MarathonParameters
}

var map_MarathonPortMapping = map[string]string{
	"":              "PortMapping is the portmapping structure between container and mesos",
	"containerPort": "container port refers to the port the application listens to inside of the container.",
	"hostPort":      "hostPort is optional and defaults to 0. 0 retains the traditional meaning in Marathon, which is \"a random port from the range included in the Mesos resource offer\". The resulting host ports for each task are exposed via the task details in the REST API and the Marathon web UI.",
	"servicePort":   "\n is a helper port intended for doing service discovery using a well-known port per service. The assigned servicePort value is not used/interpreted by Marathon itself but supposed to used by load balancer infrastructure.",
	"protocol":      "The \"protocol\" parameter is optional and defaults to \"tcp\". Its possible values are \"tcp\" and \"udp\"",
}

func (MarathonPortMapping) SwaggerDoc() map[string]string {
	return map_MarathonPortMapping
}

var map_MarathonUpgradeStrategy = map[string]string{
	"": "The upgradeStrategy controls how Marathon stops old versions and launches new versions.",
	"minimumHealthCapacity": "\n (Optional. Default: 1.0) - a number between 0and 1 that is multiplied with the instance count. This is the minimum number of healthy nodes that do not sacrifice overall application purpose. Marathon will make sure, during the upgrade process, that at any point of time this number of healthy instances are up.",
	"maximumOverCapacity":   "(Optional. Default: 1.0) - a number between 0 and 1 which is multiplied with the instance count. This is the maximum number of additional instances launched at any point of time during the upgrade process.",
}

func (MarathonUpgradeStrategy) SwaggerDoc() map[string]string {
	return map_MarathonUpgradeStrategy
}

var map_MarathonVolume = map[string]string{
	"":              "Volume is the docker volume details associated to the container",
	"containerPath": "container path refers to the volume path the application accesses inside of the container.",
	"hostPath":      "host path refers to the local host volume path to be mounted by the container.",
	"mode":          "Read/Write mode of the mounted volume inside of the container. \"R\"/\"W\"/\"RW\"",
}

func (MarathonVolume) SwaggerDoc() map[string]string {
	return map_MarathonVolume
}

var map_RecreateDeploymentStrategyParams = map[string]string{
	"":               "RecreateDeploymentStrategyParams are the input to the Recreate deployment strategy.",
	"timeoutSeconds": "TimeoutSeconds is the time to wait for updates before giving up. If the value is nil, a default will be used.",
	"pre":            "Pre is a lifecycle hook which is executed before the strategy manipulates the deployment. All LifecycleHookFailurePolicy values are supported.",
	"mid":            "Mid is a lifecycle hook which is executed while the deployment is scaled down to zero before the first new pod is created. All LifecycleHookFailurePolicy values are supported.",
	"post":           "Post is a lifecycle hook which is executed after the strategy has finished all deployment logic. All LifecycleHookFailurePolicy values are supported.",
}

func (RecreateDeploymentStrategyParams) SwaggerDoc() map[string]string {
	return map_RecreateDeploymentStrategyParams
}

var map_RollingDeploymentStrategyParams = map[string]string{
	"": "RollingDeploymentStrategyParams are the input to the Rolling deployment strategy.",
	"updatePeriodSeconds": "UpdatePeriodSeconds is the time to wait between individual pod updates. If the value is nil, a default will be used.",
	"intervalSeconds":     "IntervalSeconds is the time to wait between polling deployment status after update. If the value is nil, a default will be used.",
	"timeoutSeconds":      "TimeoutSeconds is the time to wait for updates before giving up. If the value is nil, a default will be used.",
	"maxUnavailable":      "MaxUnavailable is the maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total pods at the start of update (ex: 10%). Absolute number is calculated from percentage by rounding up.\n\nThis cannot be 0 if MaxSurge is 0. By default, 25% is used.\n\nExample: when this is set to 30%, the old RC can be scaled down by 30% immediately when the rolling update starts. Once new pods are ready, old RC can be scaled down further, followed by scaling up the new RC, ensuring that at least 70% of original number of pods are available at all times during the update.",
	"maxSurge":            "MaxSurge is the maximum number of pods that can be scheduled above the original number of pods. Value can be an absolute number (ex: 5) or a percentage of total pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up.\n\nThis cannot be 0 if MaxUnavailable is 0. By default, 25% is used.\n\nExample: when this is set to 30%, the new RC can be scaled up by 30% immediately when the rolling update starts. Once old pods have been killed, new RC can be scaled up further, ensuring that total number of pods running at any time during the update is atmost 130% of original pods.",
	"updatePercent":       "UpdatePercent is the percentage of replicas to scale up or down each interval. If nil, one replica will be scaled up and down each interval. If negative, the scale order will be down/up instead of up/down. DEPRECATED: Use MaxUnavailable/MaxSurge instead.",
	"pre":                 "Pre is a lifecycle hook which is executed before the deployment process begins. All LifecycleHookFailurePolicy values are supported.",
	"post":                "Post is a lifecycle hook which is executed after the strategy has finished all deployment logic. The LifecycleHookFailurePolicyAbort policy is NOT supported.",
}

func (RollingDeploymentStrategyParams) SwaggerDoc() map[string]string {
	return map_RollingDeploymentStrategyParams
}

var map_TagImageHook = map[string]string{
	"":              "TagImageHook is a request to tag the image in a particular container onto an ImageStreamTag.",
	"containerName": "ContainerName is the name of a container in the deployment config whose image value will be used as the source of the tag. If there is only a single container this value will be defaulted to the name of that container.",
	"to":            "To is the target ImageStreamTag to set the container's image onto.",
}

func (TagImageHook) SwaggerDoc() map[string]string {
	return map_TagImageHook
}
