// +build !ignore_autogenerated_openshift

// This file was autogenerated by deepcopy-gen. Do not edit it manually!

package v1

import (
	api "k8s.io/kubernetes/pkg/api"
	unversioned "k8s.io/kubernetes/pkg/api/unversioned"
	api_v1 "k8s.io/kubernetes/pkg/api/v1"
	conversion "k8s.io/kubernetes/pkg/conversion"
	intstr "k8s.io/kubernetes/pkg/util/intstr"
)

func init() {
	if err := api.Scheme.AddGeneratedDeepCopyFuncs(
		DeepCopy_v1_CustomDeploymentStrategyParams,
		DeepCopy_v1_DeploymentCause,
		DeepCopy_v1_DeploymentCauseImageTrigger,
		DeepCopy_v1_DeploymentConfig,
		DeepCopy_v1_DeploymentConfigList,
		DeepCopy_v1_DeploymentConfigRollback,
		DeepCopy_v1_DeploymentConfigRollbackSpec,
		DeepCopy_v1_DeploymentConfigSpec,
		DeepCopy_v1_DeploymentConfigStatus,
		DeepCopy_v1_DeploymentDetails,
		DeepCopy_v1_DeploymentLog,
		DeepCopy_v1_DeploymentLogOptions,
		DeepCopy_v1_DeploymentStrategy,
		DeepCopy_v1_DeploymentTriggerImageChangeParams,
		DeepCopy_v1_DeploymentTriggerPolicy,
		DeepCopy_v1_ExecNewPodHook,
		DeepCopy_v1_LifecycleHook,
		DeepCopy_v1_MarathonApplication,
		DeepCopy_v1_MarathonConstraint,
		DeepCopy_v1_MarathonContainer,
		DeepCopy_v1_MarathonDocker,
		DeepCopy_v1_MarathonFetch,
		DeepCopy_v1_MarathonHealthCheck,
		DeepCopy_v1_MarathonParameters,
		DeepCopy_v1_MarathonPortMapping,
		DeepCopy_v1_MarathonUpgradeStrategy,
		DeepCopy_v1_MarathonVolume,
		DeepCopy_v1_RecreateDeploymentStrategyParams,
		DeepCopy_v1_RollingDeploymentStrategyParams,
		DeepCopy_v1_TagImageHook,
	); err != nil {
		// if one of the deep copy functions is malformed, detect it immediately.
		panic(err)
	}
}

func DeepCopy_v1_CustomDeploymentStrategyParams(in CustomDeploymentStrategyParams, out *CustomDeploymentStrategyParams, c *conversion.Cloner) error {
	out.Image = in.Image
	if in.Environment != nil {
		in, out := in.Environment, &out.Environment
		*out = make([]api_v1.EnvVar, len(in))
		for i := range in {
			if err := api_v1.DeepCopy_v1_EnvVar(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Environment = nil
	}
	if in.Command != nil {
		in, out := in.Command, &out.Command
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Command = nil
	}
	return nil
}

func DeepCopy_v1_DeploymentCause(in DeploymentCause, out *DeploymentCause, c *conversion.Cloner) error {
	out.Type = in.Type
	if in.ImageTrigger != nil {
		in, out := in.ImageTrigger, &out.ImageTrigger
		*out = new(DeploymentCauseImageTrigger)
		if err := DeepCopy_v1_DeploymentCauseImageTrigger(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.ImageTrigger = nil
	}
	return nil
}

func DeepCopy_v1_DeploymentCauseImageTrigger(in DeploymentCauseImageTrigger, out *DeploymentCauseImageTrigger, c *conversion.Cloner) error {
	if err := api_v1.DeepCopy_v1_ObjectReference(in.From, &out.From, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1_DeploymentConfig(in DeploymentConfig, out *DeploymentConfig, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := api_v1.DeepCopy_v1_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1_DeploymentConfigSpec(in.Spec, &out.Spec, c); err != nil {
		return err
	}
	if err := DeepCopy_v1_DeploymentConfigStatus(in.Status, &out.Status, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1_DeploymentConfigList(in DeploymentConfigList, out *DeploymentConfigList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]DeploymentConfig, len(in))
		for i := range in {
			if err := DeepCopy_v1_DeploymentConfig(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1_DeploymentConfigRollback(in DeploymentConfigRollback, out *DeploymentConfigRollback, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	out.Name = in.Name
	if in.UpdatedAnnotations != nil {
		in, out := in.UpdatedAnnotations, &out.UpdatedAnnotations
		*out = make(map[string]string)
		for key, val := range in {
			(*out)[key] = val
		}
	} else {
		out.UpdatedAnnotations = nil
	}
	if err := DeepCopy_v1_DeploymentConfigRollbackSpec(in.Spec, &out.Spec, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1_DeploymentConfigRollbackSpec(in DeploymentConfigRollbackSpec, out *DeploymentConfigRollbackSpec, c *conversion.Cloner) error {
	if err := api_v1.DeepCopy_v1_ObjectReference(in.From, &out.From, c); err != nil {
		return err
	}
	out.Revision = in.Revision
	out.IncludeTriggers = in.IncludeTriggers
	out.IncludeTemplate = in.IncludeTemplate
	out.IncludeReplicationMeta = in.IncludeReplicationMeta
	out.IncludeStrategy = in.IncludeStrategy
	return nil
}

func DeepCopy_v1_DeploymentConfigSpec(in DeploymentConfigSpec, out *DeploymentConfigSpec, c *conversion.Cloner) error {
	if err := DeepCopy_v1_DeploymentStrategy(in.Strategy, &out.Strategy, c); err != nil {
		return err
	}
	out.MinReadySeconds = in.MinReadySeconds
	if in.Triggers != nil {
		in, out := in.Triggers, &out.Triggers
		*out = make(DeploymentTriggerPolicies, len(in))
		for i := range in {
			if err := DeepCopy_v1_DeploymentTriggerPolicy(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Triggers = nil
	}
	out.Replicas = in.Replicas
	if in.RevisionHistoryLimit != nil {
		in, out := in.RevisionHistoryLimit, &out.RevisionHistoryLimit
		*out = new(int32)
		**out = *in
	} else {
		out.RevisionHistoryLimit = nil
	}
	out.Test = in.Test
	out.Paused = in.Paused
	if in.Selector != nil {
		in, out := in.Selector, &out.Selector
		*out = make(map[string]string)
		for key, val := range in {
			(*out)[key] = val
		}
	} else {
		out.Selector = nil
	}
	if in.Template != nil {
		in, out := in.Template, &out.Template
		*out = new(api_v1.PodTemplateSpec)
		if err := api_v1.DeepCopy_v1_PodTemplateSpec(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Template = nil
	}
	out.Site = in.Site
	if in.MarathonAppTemplate != nil {
		in, out := in.MarathonAppTemplate, &out.MarathonAppTemplate
		*out = new(MarathonApplication)
		if err := DeepCopy_v1_MarathonApplication(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.MarathonAppTemplate = nil
	}
	return nil
}

func DeepCopy_v1_DeploymentConfigStatus(in DeploymentConfigStatus, out *DeploymentConfigStatus, c *conversion.Cloner) error {
	out.LatestVersion = in.LatestVersion
	out.ObservedGeneration = in.ObservedGeneration
	out.Replicas = in.Replicas
	out.UpdatedReplicas = in.UpdatedReplicas
	out.AvailableReplicas = in.AvailableReplicas
	out.UnavailableReplicas = in.UnavailableReplicas
	if in.Details != nil {
		in, out := in.Details, &out.Details
		*out = new(DeploymentDetails)
		if err := DeepCopy_v1_DeploymentDetails(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Details = nil
	}
	return nil
}

func DeepCopy_v1_DeploymentDetails(in DeploymentDetails, out *DeploymentDetails, c *conversion.Cloner) error {
	out.Message = in.Message
	if in.Causes != nil {
		in, out := in.Causes, &out.Causes
		*out = make([]DeploymentCause, len(in))
		for i := range in {
			if err := DeepCopy_v1_DeploymentCause(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Causes = nil
	}
	return nil
}

func DeepCopy_v1_DeploymentLog(in DeploymentLog, out *DeploymentLog, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1_DeploymentLogOptions(in DeploymentLogOptions, out *DeploymentLogOptions, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	out.Container = in.Container
	out.Follow = in.Follow
	out.Previous = in.Previous
	if in.SinceSeconds != nil {
		in, out := in.SinceSeconds, &out.SinceSeconds
		*out = new(int64)
		**out = *in
	} else {
		out.SinceSeconds = nil
	}
	if in.SinceTime != nil {
		in, out := in.SinceTime, &out.SinceTime
		*out = new(unversioned.Time)
		if err := unversioned.DeepCopy_unversioned_Time(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.SinceTime = nil
	}
	out.Timestamps = in.Timestamps
	if in.TailLines != nil {
		in, out := in.TailLines, &out.TailLines
		*out = new(int64)
		**out = *in
	} else {
		out.TailLines = nil
	}
	if in.LimitBytes != nil {
		in, out := in.LimitBytes, &out.LimitBytes
		*out = new(int64)
		**out = *in
	} else {
		out.LimitBytes = nil
	}
	out.NoWait = in.NoWait
	if in.Version != nil {
		in, out := in.Version, &out.Version
		*out = new(int64)
		**out = *in
	} else {
		out.Version = nil
	}
	return nil
}

func DeepCopy_v1_DeploymentStrategy(in DeploymentStrategy, out *DeploymentStrategy, c *conversion.Cloner) error {
	out.Type = in.Type
	if in.CustomParams != nil {
		in, out := in.CustomParams, &out.CustomParams
		*out = new(CustomDeploymentStrategyParams)
		if err := DeepCopy_v1_CustomDeploymentStrategyParams(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.CustomParams = nil
	}
	if in.RecreateParams != nil {
		in, out := in.RecreateParams, &out.RecreateParams
		*out = new(RecreateDeploymentStrategyParams)
		if err := DeepCopy_v1_RecreateDeploymentStrategyParams(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.RecreateParams = nil
	}
	if in.RollingParams != nil {
		in, out := in.RollingParams, &out.RollingParams
		*out = new(RollingDeploymentStrategyParams)
		if err := DeepCopy_v1_RollingDeploymentStrategyParams(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.RollingParams = nil
	}
	if err := api_v1.DeepCopy_v1_ResourceRequirements(in.Resources, &out.Resources, c); err != nil {
		return err
	}
	if in.Labels != nil {
		in, out := in.Labels, &out.Labels
		*out = make(map[string]string)
		for key, val := range in {
			(*out)[key] = val
		}
	} else {
		out.Labels = nil
	}
	if in.Annotations != nil {
		in, out := in.Annotations, &out.Annotations
		*out = make(map[string]string)
		for key, val := range in {
			(*out)[key] = val
		}
	} else {
		out.Annotations = nil
	}
	return nil
}

func DeepCopy_v1_DeploymentTriggerImageChangeParams(in DeploymentTriggerImageChangeParams, out *DeploymentTriggerImageChangeParams, c *conversion.Cloner) error {
	out.Automatic = in.Automatic
	if in.ContainerNames != nil {
		in, out := in.ContainerNames, &out.ContainerNames
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.ContainerNames = nil
	}
	if err := api_v1.DeepCopy_v1_ObjectReference(in.From, &out.From, c); err != nil {
		return err
	}
	out.LastTriggeredImage = in.LastTriggeredImage
	return nil
}

func DeepCopy_v1_DeploymentTriggerPolicy(in DeploymentTriggerPolicy, out *DeploymentTriggerPolicy, c *conversion.Cloner) error {
	out.Type = in.Type
	if in.ImageChangeParams != nil {
		in, out := in.ImageChangeParams, &out.ImageChangeParams
		*out = new(DeploymentTriggerImageChangeParams)
		if err := DeepCopy_v1_DeploymentTriggerImageChangeParams(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.ImageChangeParams = nil
	}
	return nil
}

func DeepCopy_v1_ExecNewPodHook(in ExecNewPodHook, out *ExecNewPodHook, c *conversion.Cloner) error {
	if in.Command != nil {
		in, out := in.Command, &out.Command
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Command = nil
	}
	if in.Env != nil {
		in, out := in.Env, &out.Env
		*out = make([]api_v1.EnvVar, len(in))
		for i := range in {
			if err := api_v1.DeepCopy_v1_EnvVar(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Env = nil
	}
	out.ContainerName = in.ContainerName
	if in.Volumes != nil {
		in, out := in.Volumes, &out.Volumes
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Volumes = nil
	}
	return nil
}

func DeepCopy_v1_LifecycleHook(in LifecycleHook, out *LifecycleHook, c *conversion.Cloner) error {
	out.FailurePolicy = in.FailurePolicy
	if in.ExecNewPod != nil {
		in, out := in.ExecNewPod, &out.ExecNewPod
		*out = new(ExecNewPodHook)
		if err := DeepCopy_v1_ExecNewPodHook(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.ExecNewPod = nil
	}
	if in.TagImages != nil {
		in, out := in.TagImages, &out.TagImages
		*out = make([]TagImageHook, len(in))
		for i := range in {
			if err := DeepCopy_v1_TagImageHook(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.TagImages = nil
	}
	return nil
}

func DeepCopy_v1_MarathonApplication(in MarathonApplication, out *MarathonApplication, c *conversion.Cloner) error {
	out.ID = in.ID
	if in.Cmd != nil {
		in, out := in.Cmd, &out.Cmd
		*out = new(string)
		**out = *in
	} else {
		out.Cmd = nil
	}
	if in.Args != nil {
		in, out := in.Args, &out.Args
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Args = nil
	}
	if in.Constraints != nil {
		in, out := in.Constraints, &out.Constraints
		*out = make([]MarathonConstraint, len(in))
		for i := range in {
			if err := DeepCopy_v1_MarathonConstraint(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Constraints = nil
	}
	if in.Container != nil {
		in, out := in.Container, &out.Container
		*out = new(MarathonContainer)
		if err := DeepCopy_v1_MarathonContainer(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Container = nil
	}
	if in.CPUs != nil {
		in, out := in.CPUs, &out.CPUs
		*out = new(float64)
		**out = *in
	} else {
		out.CPUs = nil
	}
	if in.Disk != nil {
		in, out := in.Disk, &out.Disk
		*out = new(float64)
		**out = *in
	} else {
		out.Disk = nil
	}
	if in.Env != nil {
		in, out := in.Env, &out.Env
		*out = make(map[string]string)
		for key, val := range in {
			(*out)[key] = val
		}
	} else {
		out.Env = nil
	}
	if in.Executor != nil {
		in, out := in.Executor, &out.Executor
		*out = new(string)
		**out = *in
	} else {
		out.Executor = nil
	}
	if in.HealthChecks != nil {
		in, out := in.HealthChecks, &out.HealthChecks
		*out = make([]MarathonHealthCheck, len(in))
		for i := range in {
			if err := DeepCopy_v1_MarathonHealthCheck(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.HealthChecks = nil
	}
	if in.Mem != nil {
		in, out := in.Mem, &out.Mem
		*out = new(float64)
		**out = *in
	} else {
		out.Mem = nil
	}
	if in.Ports != nil {
		in, out := in.Ports, &out.Ports
		*out = make([]int32, len(in))
		copy(*out, in)
	} else {
		out.Ports = nil
	}
	if in.RequirePorts != nil {
		in, out := in.RequirePorts, &out.RequirePorts
		*out = new(bool)
		**out = *in
	} else {
		out.RequirePorts = nil
	}
	if in.BackoffSeconds != nil {
		in, out := in.BackoffSeconds, &out.BackoffSeconds
		*out = new(float64)
		**out = *in
	} else {
		out.BackoffSeconds = nil
	}
	if in.BackoffFactor != nil {
		in, out := in.BackoffFactor, &out.BackoffFactor
		*out = new(float64)
		**out = *in
	} else {
		out.BackoffFactor = nil
	}
	if in.MaxLaunchDelaySeconds != nil {
		in, out := in.MaxLaunchDelaySeconds, &out.MaxLaunchDelaySeconds
		*out = new(float64)
		**out = *in
	} else {
		out.MaxLaunchDelaySeconds = nil
	}
	if in.Dependencies != nil {
		in, out := in.Dependencies, &out.Dependencies
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Dependencies = nil
	}
	out.User = in.User
	if in.UpgradeStrategy != nil {
		in, out := in.UpgradeStrategy, &out.UpgradeStrategy
		*out = new(MarathonUpgradeStrategy)
		if err := DeepCopy_v1_MarathonUpgradeStrategy(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.UpgradeStrategy = nil
	}
	if in.Uris != nil {
		in, out := in.Uris, &out.Uris
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Uris = nil
	}
	if in.Labels != nil {
		in, out := in.Labels, &out.Labels
		*out = make(map[string]string)
		for key, val := range in {
			(*out)[key] = val
		}
	} else {
		out.Labels = nil
	}
	if in.AcceptedResourceRoles != nil {
		in, out := in.AcceptedResourceRoles, &out.AcceptedResourceRoles
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.AcceptedResourceRoles = nil
	}
	if in.Fetch != nil {
		in, out := in.Fetch, &out.Fetch
		*out = make([]MarathonFetch, len(in))
		for i := range in {
			if err := DeepCopy_v1_MarathonFetch(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Fetch = nil
	}
	return nil
}

func DeepCopy_v1_MarathonConstraint(in MarathonConstraint, out *MarathonConstraint, c *conversion.Cloner) error {
	if in.Constraint != nil {
		in, out := in.Constraint, &out.Constraint
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Constraint = nil
	}
	return nil
}

func DeepCopy_v1_MarathonContainer(in MarathonContainer, out *MarathonContainer, c *conversion.Cloner) error {
	out.Type = in.Type
	if in.Docker != nil {
		in, out := in.Docker, &out.Docker
		*out = new(MarathonDocker)
		if err := DeepCopy_v1_MarathonDocker(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Docker = nil
	}
	if in.Volumes != nil {
		in, out := in.Volumes, &out.Volumes
		*out = make([]MarathonVolume, len(in))
		for i := range in {
			if err := DeepCopy_v1_MarathonVolume(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Volumes = nil
	}
	return nil
}

func DeepCopy_v1_MarathonDocker(in MarathonDocker, out *MarathonDocker, c *conversion.Cloner) error {
	if in.ForcePullImage != nil {
		in, out := in.ForcePullImage, &out.ForcePullImage
		*out = new(bool)
		**out = *in
	} else {
		out.ForcePullImage = nil
	}
	out.Image = in.Image
	out.Network = in.Network
	if in.Parameters != nil {
		in, out := in.Parameters, &out.Parameters
		*out = make([]MarathonParameters, len(in))
		for i := range in {
			if err := DeepCopy_v1_MarathonParameters(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Parameters = nil
	}
	if in.PortMappings != nil {
		in, out := in.PortMappings, &out.PortMappings
		*out = make([]MarathonPortMapping, len(in))
		for i := range in {
			if err := DeepCopy_v1_MarathonPortMapping(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.PortMappings = nil
	}
	if in.Privileged != nil {
		in, out := in.Privileged, &out.Privileged
		*out = new(bool)
		**out = *in
	} else {
		out.Privileged = nil
	}
	return nil
}

func DeepCopy_v1_MarathonFetch(in MarathonFetch, out *MarathonFetch, c *conversion.Cloner) error {
	out.URI = in.URI
	out.Executable = in.Executable
	out.Extract = in.Extract
	out.Cache = in.Cache
	return nil
}

func DeepCopy_v1_MarathonHealthCheck(in MarathonHealthCheck, out *MarathonHealthCheck, c *conversion.Cloner) error {
	if in.Command != nil {
		in, out := in.Command, &out.Command
		*out = new(string)
		**out = *in
	} else {
		out.Command = nil
	}
	if in.PortIndex != nil {
		in, out := in.PortIndex, &out.PortIndex
		*out = new(int32)
		**out = *in
	} else {
		out.PortIndex = nil
	}
	if in.Path != nil {
		in, out := in.Path, &out.Path
		*out = new(string)
		**out = *in
	} else {
		out.Path = nil
	}
	if in.MaxConsecutiveFailures != nil {
		in, out := in.MaxConsecutiveFailures, &out.MaxConsecutiveFailures
		*out = new(int32)
		**out = *in
	} else {
		out.MaxConsecutiveFailures = nil
	}
	out.Protocol = in.Protocol
	out.GracePeriodSeconds = in.GracePeriodSeconds
	out.IntervalSeconds = in.IntervalSeconds
	out.TimeoutSeconds = in.TimeoutSeconds
	return nil
}

func DeepCopy_v1_MarathonParameters(in MarathonParameters, out *MarathonParameters, c *conversion.Cloner) error {
	out.Key = in.Key
	out.Value = in.Value
	return nil
}

func DeepCopy_v1_MarathonPortMapping(in MarathonPortMapping, out *MarathonPortMapping, c *conversion.Cloner) error {
	out.ContainerPort = in.ContainerPort
	out.HostPort = in.HostPort
	out.ServicePort = in.ServicePort
	out.Protocol = in.Protocol
	return nil
}

func DeepCopy_v1_MarathonUpgradeStrategy(in MarathonUpgradeStrategy, out *MarathonUpgradeStrategy, c *conversion.Cloner) error {
	out.MinimumHealthCapacity = in.MinimumHealthCapacity
	out.MaximumOverCapacity = in.MaximumOverCapacity
	return nil
}

func DeepCopy_v1_MarathonVolume(in MarathonVolume, out *MarathonVolume, c *conversion.Cloner) error {
	out.ContainerPath = in.ContainerPath
	out.HostPath = in.HostPath
	out.Mode = in.Mode
	return nil
}

func DeepCopy_v1_RecreateDeploymentStrategyParams(in RecreateDeploymentStrategyParams, out *RecreateDeploymentStrategyParams, c *conversion.Cloner) error {
	if in.TimeoutSeconds != nil {
		in, out := in.TimeoutSeconds, &out.TimeoutSeconds
		*out = new(int64)
		**out = *in
	} else {
		out.TimeoutSeconds = nil
	}
	if in.Pre != nil {
		in, out := in.Pre, &out.Pre
		*out = new(LifecycleHook)
		if err := DeepCopy_v1_LifecycleHook(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Pre = nil
	}
	if in.Mid != nil {
		in, out := in.Mid, &out.Mid
		*out = new(LifecycleHook)
		if err := DeepCopy_v1_LifecycleHook(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Mid = nil
	}
	if in.Post != nil {
		in, out := in.Post, &out.Post
		*out = new(LifecycleHook)
		if err := DeepCopy_v1_LifecycleHook(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Post = nil
	}
	return nil
}

func DeepCopy_v1_RollingDeploymentStrategyParams(in RollingDeploymentStrategyParams, out *RollingDeploymentStrategyParams, c *conversion.Cloner) error {
	if in.UpdatePeriodSeconds != nil {
		in, out := in.UpdatePeriodSeconds, &out.UpdatePeriodSeconds
		*out = new(int64)
		**out = *in
	} else {
		out.UpdatePeriodSeconds = nil
	}
	if in.IntervalSeconds != nil {
		in, out := in.IntervalSeconds, &out.IntervalSeconds
		*out = new(int64)
		**out = *in
	} else {
		out.IntervalSeconds = nil
	}
	if in.TimeoutSeconds != nil {
		in, out := in.TimeoutSeconds, &out.TimeoutSeconds
		*out = new(int64)
		**out = *in
	} else {
		out.TimeoutSeconds = nil
	}
	if in.MaxUnavailable != nil {
		in, out := in.MaxUnavailable, &out.MaxUnavailable
		*out = new(intstr.IntOrString)
		if err := intstr.DeepCopy_intstr_IntOrString(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.MaxUnavailable = nil
	}
	if in.MaxSurge != nil {
		in, out := in.MaxSurge, &out.MaxSurge
		*out = new(intstr.IntOrString)
		if err := intstr.DeepCopy_intstr_IntOrString(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.MaxSurge = nil
	}
	if in.UpdatePercent != nil {
		in, out := in.UpdatePercent, &out.UpdatePercent
		*out = new(int32)
		**out = *in
	} else {
		out.UpdatePercent = nil
	}
	if in.Pre != nil {
		in, out := in.Pre, &out.Pre
		*out = new(LifecycleHook)
		if err := DeepCopy_v1_LifecycleHook(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Pre = nil
	}
	if in.Post != nil {
		in, out := in.Post, &out.Post
		*out = new(LifecycleHook)
		if err := DeepCopy_v1_LifecycleHook(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Post = nil
	}
	return nil
}

func DeepCopy_v1_TagImageHook(in TagImageHook, out *TagImageHook, c *conversion.Cloner) error {
	out.ContainerName = in.ContainerName
	if err := api_v1.DeepCopy_v1_ObjectReference(in.To, &out.To, c); err != nil {
		return err
	}
	return nil
}
